import re
import time
import datetime
import requests
import logging

from . import __version__
from .recipe import get_recipes_list
from .status import get_status
from .github import get_github_token
from .update import update_one_recipe, BranchAlreadyExists
from .cci import cci_interface


ISSUE_URL_RE = re.compile(r"github.com/([^/]+)/([^/]+)/issues/([0-9]+)")
logger = logging.getLogger(__name__)


def _format_duration(duration):
    minutes = duration // 60
    seconds = duration % 60

    if minutes > 0:
        return f"{int(minutes)}m {int(seconds)}s"
    return f"{seconds:.1f}s"


def _update_issue(issue_url, content):
    match = ISSUE_URL_RE.search(issue_url)
    if not match:
        logger.error("update failed: bad issue URL")
        return False

    owner, repo, issue_number = match.groups()
    url = f"https://api.github.com/repos/{owner}/{repo}/issues/{issue_number}"
    github_token = get_github_token()
    headers = {"Accept": "application/vnd.github.v3+json"}
    if github_token:
        headers["Authorization"] = f"token {github_token}"
    data = {"body": content}
    resp = requests.patch(url, json=data, headers=headers)
    if resp.ok:
        return True

    logger.error(f"update failed: {resp.reason}")
    return False


def update_status_issue(cci_path, issue_url_list, jobs):
    t0 = time.time()
    recipes = get_recipes_list(cci_path)
    status = get_status(cci_path, recipes, jobs)
    status = [s for s in status if not s.deprecated]
    updatable = [s for s in status if s.update_possible()]
    inconsistent_version = [s for s in status if s.inconsistent_versioning()]
    duration = time.time() - t0

    def make_pr_text(status):
        prs = status.prs_opened()
        if not prs:
            return "No"
        return ", ".join([f"[#{pr.number}]({pr.url})" for pr in prs])

    date = datetime.datetime.now().strftime("%d/%m/%Y")
    text = "\n".join(
        [
            "# Conan Center Bot",
            "",
            f"* Date: {date}",
            f"* Parsed recipes: {len(recipes)}",
            f"* Updatable recipes: {len(updatable)}",
            f"* Duration: {_format_duration(duration)}",
            f"* Version: {__version__}",
            "",
            "This list is auto-generated by [Conan Center Bot](https://github.com/qchateau/conan-center-bot) "
            "and the updatability detection or version parsing can be flawed. Any help improving "
            "this tool is welcome !",
            "",
            "You can also use [Conan Center Bot](https://github.com/qchateau/conan-center-bot) "
            "to automatically generate an update for a recipe.",
            "",
            "### Updatable recipes" "",
            "|Name|Recipe version|New version|Upstream version|Pending PR|",
            "|----|--------------|-----------|----------------|----------|",
        ]
        + [
            "|".join(
                [
                    "",
                    f"[{s.name}]({s.homepage})" if s.homepage else f"{s.name}",
                    f"{s.recipe_version}",
                    f"{s.upstream_version.fixed}",
                    f"{s.upstream_version}",
                    make_pr_text(s),
                    "",
                ]
            )
            for s in sorted(updatable, key=lambda s: s.name)
        ]
        + [
            "",
            "### Inconsistent recipes",
            "",
            "The following recipes are not consistent with their upstream versioning scheme. "
            "Most of the times it means the current recipe version is not related to any upstream tag.",
            "",
            "|Name|Current recipe version|Upstream version|",
            "|----|----------------------|----------------|",
        ]
        + [
            "|".join(
                [
                    "",
                    f"[{s.name}]({s.homepage})" if s.homepage else f"{s.name}",
                    f"{s.recipe_version}",
                    f"{s.upstream_version}",
                    "",
                ]
            )
            for s in sorted(inconsistent_version, key=lambda s: s.name)
        ]
    )

    print(text)
    if issue_url_list:
        ok = True
        for issue_url in issue_url_list:
            ok = _update_issue(issue_url, text) and ok
    else:
        ok = True

    return 0 if ok else 1


def update_full_status_issue(
    cci_path,
    issue_url_list,
    status_jobs,
):
    t0 = time.time()
    recipes = get_recipes_list(cci_path)
    status = get_status(cci_path, recipes, status_jobs)
    status = [s for s in status if not s.deprecated]
    updatable = [s for s in status if s.update_possible()]
    inconsistent_version = [s for s in status if s.inconsistent_versioning()]

    errors = dict()
    branches = dict()
    for i, recipe_status in enumerate(updatable):
        print(f"===== [{i+1:3}/{len(updatable):3}] {recipe_status.name} =====")

        if recipe_status.prs_opened():
            errors[recipe_status.name] = f"PR already exists"
            logger.info("%s: skipped (PR exists)", recipe_status.name)
            continue

        try:
            branches[recipe_status.name] = update_one_recipe(
                cci_path=cci_path,
                recipe_name=recipe_status.name,
                choose_version=False,
                folder=None,
                run_test=True,
                push_to="origin",
                force=False,
                allow_interaction=False,
            )
        except BranchAlreadyExists as exc:
            logger.info("%s: skipped (%s)", recipe_status.name, str(exc))
            branches[recipe_status.name] = exc.branch_name
        except Exception as exc:
            errors[recipe_status.name] = f"{exc}"
            logger.error("%s: %s", recipe_status.name, str(exc))

    duration = time.time() - t0

    def make_pr_text(status):
        prs = status.prs_opened()
        if not prs:
            return "No"
        return ", ".join([f"[#{pr.number}]({pr.url})" for pr in prs])

    def make_branch_text(status):
        err = errors.get(status.name)
        branch = branches.get(status.name)
        if err is not None:
            return str(err)
        if branch is not None:
            owner, repo = cci_interface.owner_and_repo(cci_path)
            return f"[{branch}](https://github.com/{owner}/{repo}/pull/new/{branch})"

        return f"Error: unexpected"

    date = datetime.datetime.now().strftime("%d/%m/%Y")
    text = "\n".join(
        [
            "# Conan Center Bot",
            "",
            f"* Date: {date}",
            f"* Parsed recipes: {len(recipes)}",
            f"* Updatable recipes: {len(updatable)}",
            f"* Duration: {_format_duration(duration)}",
            f"* Version: {__version__}",
            "",
            "This list is auto-generated by [Conan Center Bot](https://github.com/qchateau/conan-center-bot) "
            "and the updatability detection or version parsing can be flawed. Any help improving "
            "this tool is welcome !",
            "",
            "You can also use [Conan Center Bot](https://github.com/qchateau/conan-center-bot) "
            "to automatically generate an update for a recipe.",
            "",
            "### Updatable recipes" "",
            "|Name|Recipe version|New version|Upstream version|Pending PR|Updated branch|",
            "|----|--------------|-----------|----------------|----------|--------------|",
        ]
        + [
            "|".join(
                [
                    "",
                    f"[{s.name}]({s.homepage})" if s.homepage else f"{s.name}",
                    f"{s.recipe_version}",
                    f"{s.upstream_version.fixed}",
                    f"{s.upstream_version}",
                    make_pr_text(s),
                    make_branch_text(s),
                    "",
                ]
            )
            for s in sorted(updatable, key=lambda s: s.name)
        ]
        + [
            "",
            "### Inconsistent recipes",
            "",
            "The following recipes are not consistent with their upstream versioning scheme. "
            "Most of the times it means the current recipe version is not related to any upstream tag.",
            "",
            "|Name|Current recipe version|Upstream version|",
            "|----|----------------------|----------------|",
        ]
        + [
            "|".join(
                [
                    "",
                    f"[{s.name}]({s.homepage})" if s.homepage else f"{s.name}",
                    f"{s.recipe_version}",
                    f"{s.upstream_version}",
                    "",
                ]
            )
            for s in sorted(inconsistent_version, key=lambda s: s.name)
        ]
    )

    print(text)
    if issue_url_list:
        ok = True
        for issue_url in issue_url_list:
            ok = _update_issue(issue_url, text) and ok
    else:
        ok = True

    return 0 if ok else 1
